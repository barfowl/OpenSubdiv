//
//   Copyright 2021
//
//   Licensed under the Apache License, Version 2.0 (the "Apache License")
//   with the following modification; you may not use this file except in
//   compliance with the Apache License and the following modification to it:
//   Section 6. Trademarks. is deleted and replaced with:
//
//   6. Trademarks. This License does not grant permission to use the trade
//      names, trademarks, service marks, or product names of the Licensor
//      and its affiliates, except as required to comply with Section 4(c) of
//      the License and to reproduce the content of the NOTICE file.
//
//   You may obtain a copy of the Apache License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the Apache License with the above modification is
//   distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
//   KIND, either express or implied. See the Apache License for the specific
//   language governing permissions and limitations under the Apache License.
//

#ifndef OPENSUBDIV3_BFR_TESSELLATION_H
#define OPENSUBDIV3_BFR_TESSELLATION_H

#include "../version.h"

#include "../bfr/types.h"
#include "../bfr/parameterization.h"
#include "../sdc/types.h"


namespace OpenSubdiv {
namespace OPENSUBDIV_VERSION {

namespace Bfr {

//
//  Tessellation is a simple class that provides topological information
//  for a specified tessellation pattern of a given parameterization.
//
//  WIP - Remember that use of Coord and Facet in the interface here are
//  subject to change in future.
//
class Tessellation {
public:
    //
    //  Currently the only standard option is whether to triangulate quad
    //  facets -- which are generated by default for quad or quadrangulated
    //  parameterizations.
    //
    //  WIP - triangulation of quad facets is not yet supported.
    //
    class Options {
    public:
        Options() : _triangulateFacets(false) { }

        void SetTriangulateQuadFacets(bool arg) { _triangulateFacets = arg; }
        bool GetTriangulateQuadFacets() const   { return _triangulateFacets; }

    private:
        unsigned int _triangulateFacets : 1;
    };

public:
    //
    //  Constructors require a Parameterization of a face, a set of one or
    //  more tessellation rates, and a standard set of options.
    //
    //  For a non-uniform tessellation, the number of rates specified must
    //  be at least N (for the boundary edges of an N-sided parameterization)
    //  and may optionally include one or two inner rates for a total of N+1
    //  or N+2 (two inner rates for quads only).  When not specified, a set
    //  of reasonable inner rates will be inferred from the outer rates.
    //  (Specifying the inner rates as a separate optional argument is also
    //  a possibility -- making the number of rates argument unnecessary.)
    //
    //  WIP - Consider adding a method to redefine a given instance with a
    //  new set of tessellation rates, rather than requiring a new instance.
    //
    Tessellation(Parameterization p, int uniformRate,
                 Options options = Options());
    Tessellation(Parameterization p, int numRates, int const rates[],
                 Options options = Options());
    ~Tessellation();

    //
    //  General queries:
    //
    Parameterization GetParametrization() const { return _param; }

    int GetFaceSize() const { return _param.GetFaceSize(); }

    bool IsUniform() const { return _isUniform; }

    //
    //  Queries to determine the number of sample points involved in the
    //  tessellation pattern at various features:
    //
    int GetNumCoords() const { return _numTotalPoints; }

    int GetNumInteriorCoords() const { return _numInteriorPoints; }

    int GetNumBoundaryCoords() const         { return _numBoundaryPoints; }
    int GetNumBoundaryCoords(int edge) const { return _outerRates[edge]; }

    //
    //  Methods to identify coordinates of sample points for all or specific
    //  features of the parameterization.  All such methods return the number
    //  of coordinates returned, so the above methods returning the size only
    //  are not necessary if buffers for the resulting coords have already
    //  been adequately sized:
    //
    int GetCoords(Coord coords[]) const;

    int GetInteriorCoords(Coord coords[]) const;

    int GetBoundaryCoords(Coord coords[]) const;
    int GetBoundaryCoords(int edge, bool corner0, bool corner1, Coord[]) const;

    int GetCornerCoord(int corner, Coord coords[]) const;
    int GetCornerCoords(Coord coords[]) const;

    //
    //  Methods to query the number and values of facets:
    //
    int GetNumFacets() const { return _numFacets; }

    int GetFacets(Facet facets[]) const;

    //
    //  Methods to tranform indices in the facets -- applying offsets and/or
    //  remapping of interior and boundary indices:
    //
    void TransformFacetIndices(Facet facets[], int commonOffset);
    void TransformFacetIndices(Facet facets[], int boundaryOffset,
                                               int interiorOffset);
    void TransformFacetIndices(Facet facets[], int const boundaryIndices[],
                                               int       interiorOffset);
    void TransformFacetIndices(Facet facets[], int const boundaryIndices[],
                                               int const interiorIndices[]);

private:
    //  Private methods:
    void initialize(Parameterization p, int nRates, int const rates[],
                    Options options);

private:
    //  Private members:
    Parameterization _param;

    unsigned int _isUniform : 1;

    int* _outerRates;
    int  _innerRates[2];

    int _numBoundaryPoints;
    int _numInteriorPoints;
    int _numTotalPoints;
    int _numFacets;

    int              _outerRatesLocal[4];
    std::vector<int> _outerRatesDynamic;
};

inline int
Tessellation::GetCornerCoord(int corner, Coord coords[]) const {
    _param.GetCornerCoord(corner, coords[0]);
    return 1;
}

inline int
Tessellation::GetCornerCoords(Coord coords[]) const {
    return _param.GetCornerCoords(coords);
}


} // end namespace Bfr

} // end namespace OPENSUBDIV_VERSION
using namespace OPENSUBDIV_VERSION;

} // end namespace OpenSubdiv

#endif /* OPENSUBDIV3_BFR_TESSELLATION */
